# Хакатон "Вездекод" от ВКонтакте

## Этап: Хотфикс.Мобайл

## Команда: Bepis

---

## Описание решения

```html
<meta name="referrer" content="strict-origin-when-cross-origin">
```

HTTP/HTTPS-запросы могут включать в себя опциональный заголовок `Referer`, который содержит в себе адрес веб-страницы инициатора, с которой пользователь выполнил запрос.

Данный заголовок может быть использован сервером для сбора информации об источнике посещений веб-ресурса. Это может быть полезно, например, для аналитики.

В рассматриваемой в задании ситуации браузер пользователя при скачивании картинки осуществляет HTTP/HTTPS-запрос на внешний URL с целью получения содержимого картинки, 
и заголовке `Referer` передается информация о полном адресе текущей страницы.

Хоть при запуске мини-приложения в адресной строке браузера мы и видим адрес приложения, на самом деле для его отображения используется `iframe`, 
в котором загружается страница по адресу, предоставленному разработчиком в качестве адреса своего сервиса.
Через параметры запроса в клиентскую часть сервиса попадают данные, позволяющие идентифицировать пользователя: идентификатор пользователя, его локаль, платформа и др.:
```
https://vk-vezdecode-gostev-bepis.surge.sh?vk_app_id=7595299&vk_user_id=45938510&vk_is_app_user=1&vk_language=ru&vk_platform=desktop_web&sign=...
```
... эти же данные являются частью текущего адреса iframe'а, которые далее могут быть отправлены через заголовок `Referer`.

Когда внутри мини-приложения браузер запрашивает с помощью HTTP/HTTPS-запроса изображение, которое, кстати говоря, может храниться по внешнему адресу, 
в заголовок `Referer` попадают [чувствительные данные](https://slovar.wikireading.ru/1687869), позволяющие идентифицировать пользователя.

Это потенциальная угроза безопасности приложения, так как чувствительные данные пользователи могут попасть в руки злоумышленника, Проблему можно устранить, запретив отправлять заголовок `Referer` используя подходящую политику `Referer-Policy`.

Мы выбрали политику `Referer-Policy: strict-origin-when-cross-origin`, так как она является лучшей практикой. Данная политика контролирует отправку заголовка `Referer` таким образом:
- при отправке HTTP-запроса с HTTPS-источника, заголовок не отправляется
- при отправке на внешний источник передается только источник (`Origin`)
- полный адрес источника отправляется только при запросе на тот же источник
... что гарантирует сохранность чувствительных пользовательских данных. Большинство браузеров планируют использовать данную политику как политику по-умолчанию, а некоторые уже используют (Safari).

---

## Альтернативные решения в контексте задачи

```html
<meta name="referrer" content="no-referrer">
<meta name="referrer" content="origin">
<meta name="referrer" content="strict-origin">
<meta name="referrer" content="origin-when-cross-origin">
<meta name="referrer" content="same-origin">
<img src={ image } alt="remote file" referrerPolicy="strict-origin-when-cross-origin" />
<img src={ image } alt="remote file" referrerPolicy="no-referrer" />
<img src={ image } alt="remote file" referrerPolicy="origin" />
<img src={ image } alt="remote file" referrerPolicy="strict-origin" />
<img src={ image } alt="remote file" referrerPolicy="origin-when-cross-origin" />
<img src={ image } alt="remote file" referrerPolicy="same-origin" />
```
